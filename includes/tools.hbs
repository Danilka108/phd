<hgroup>
    <h2 id="tools">Выбор средств для реализации подсистемы администрирования</h2>
    <hgroup>
        <h3 id="tools_pl">Выбор языка программирования</h3>

        <p>Выбор языка программирования, на основе которого будет реализована вся логика подсистемы — один из ключевых
            этапов ее проектирования. От этого выбора зависят производительность, объем потребляемых ресурсов, уровень
            надежности, простота сопровождения, а также доступность необходимой инфраструктуры и библиотек. В контексте
            рассматриваемой подсистемы администрирования язык должен соответствовать требованиям: поддержка асинхронного
            программирования, отсутствие тяжёлого рантайма, компактность исполняемых файлов, безопасность при работе с
            памятью и легкодоступность средств для взаимодействия с операционной системой.</p>

        <p>В качестве кандидатов для реализации подсистемы были рассмотрены следующие языки программирования: Python,
            Go, C/C++ и Rust.</p>

        <p>Python отличается простотой синтаксиса, широким спектром библиотек и высокой скоростью разработки. Но
            существенным недостатком является наличие тяжёлого интерпретатора, требующего установки полноценного
            рантайма на каждом устройстве. Кроме того, Python не обеспечивает контроль над использованием памяти и
            требует установки всех зависимостей из пакетного менеджера. В условиях ограниченного оборудования и
            отсутствия доступа к сети Python не является приемлемым решением.</p>

        <p>Go представляет собой язык с поддержкой конкурентности на базе собственного планировщика. Он предоставляет
            достаточно простую модель параллелизма и возможность компиляции программ в один исполняемый файл. Однако,
            язык для работы с памятью использует сборщик мусора, что влечет за собой увеличение потребленяемых ресурсов.
            Дополнительно, способ обработки ошибок в Go достаточно примитивен. Поэтому было решено отказаться от данного
            варианта.</p>

        <p>Языки C и C++ используются для реализации низкоуровневых и высокопроизводительных программ. Они предоставляют
            полный контроль над ресурсами, прямой доступ к системным вызовам, возможность работы без внешних
            зависимостей. Программы, созданные с их помощью, не требуют дополнительных средств для исполнения. Но данные
            языки склонны к возникновению критических сбоев и усложняют разработку. Отсутствует встроенная поддержка
            асинхронного программирования и в целом имеются сложности в плане разработки удобных и безопасных программ,
            особенно с использованием параллелизма и конкурентности. Это делает языки непригодными для безопасной
            реализации распределенной системы без значительных трудозатрат.</p>

        <p>Rust — это компилируемый язык системного программирования, который ориентируется на безопасную работу с
            памятью без использования сборщика мусора за счёт системы владения и заимствования. Модель работы с памятью
            и использование специализированных библиотек позволяют легко и безопасно разрабатывать программы, основанные
            на конкурентном исполнении задач. Исполняемые файлы, как и в случае C/C++, не требуют дополнительных
            зависимостей и полностью автономны [1, 13, 14, 15].</p>

        <p>На основании изложенного выбор был сделан в пользу языка Rust. Применение данного языка позволяет реализовать
            компоненты подсистемы администрирования в единой экосистеме, обеспечивающей согласованность, надёжность и
            предсказуемость поведения. Такой выбор полностью соответствует техническим требованиям и обеспечивает основу
            для реализации отказоустойчивой и расширяемой архитектуры.</p>
    </hgroup>
    <hgroup>
        <h3 id="tools_serialization">Выбор формата сериализации данных и протокола обмена</h3>
        <p>Немаловажным в проектировании разрабатываемой подсистемы является выбор формата сериализации данных и
            протокола обмена сообщениями между компонентами. Подсистема администрирования предполагает двустороннее
            взаимодействие между менеджером — контроллером всей подсистемы, и агентом, который отвечает за управление
            отдельным устройством. Это взаимодействие осуществляется путём обмена структурированными сообщениями, такими
            как команды, события, ошибки. В силу ограниченных ресурсов, а следовательно необходимости асинхронной
            обработки и минимизации накладных расходов, большое внимание было уделено компактности, скорости
            сериализации и простоте обработки потоков данных.</p>

        <p>В качестве кандидатов на использование в роли формата сериализации были рассмотрены: JSON, CBOR, MessagePack,
            Protocol Buffers (protobuf) и Postcard.</p>

        <p>Формат JSON является удобным для визуального восприятия и широко распространён. Однако он обладает рядом
            недостатков: текстовая природа, избыточность при передаче чисел и структур, отсутствие строгой типизации,
            необходимость дополнительного парсинга строк. Сериализация и десериализация JSON в среде с ограниченными
            ресурсами может быть ресурсоёмкой, особенно при передаче вложенных структур и бинарных данных. Было решено,
            что использование JSON нецелесообразно из-за низкой плотности представления и отсутствия типобезопасности.
        </p>

        <p>Форматы CBOR и MessagePack представляют собой компактные бинарные варианты JSON и позволяют достичь лучшей
            плотности. Однако они по-прежнему опираются на динамическую модель данных и не гарантируют строгую типовую
            согласованность между отправителем и получателем. В контексте языка Rust использование этих форматов требует
            промежуточной обработки через Value-представления или макросы с меньшей степенью контроля на этапе
            компиляции. [3]</p>

        <p>Protocol Buffers представляет собой эффективный и широко используемый формат бинарной сериализации с явным
            определением схемы. Он обеспечивает компактность, расширяемость и хорошую поддержку в разных языках. Но его
            использование в Rust сопровождается генерацией кода из специальных файлов и требует отдельного этапа
            компиляции схем, что усложняет интеграцию с внутренними типами, определяемыми непосредственно в коде.
            Protocol Buffers не являются zero-copy форматом и требуют дополнительных аллокаций, что может быть критично
            на устройствах с ограниченными ресурсами. [4]</p>

        <p>В качестве альтернативы был рассмотрен формат Postcard — бинарный формат сериализации, разработанный
            специально для встроенных и системных приложений на языке Rust. Он реализует zero-copy десериализацию,
            работает напрямую с типами языка Rust и не требует внешней схемы или генерации кода. Формат отличается
            крайне компактным представлением структур, высокой скоростью сериализации и десериализации. Все поля
            сериализуются строго по порядку, без метаинформации, что обеспечивает минимальный размер сообщений. Это
            делает его подходящим выбором в условиях ограниченных ресурсов [2].</p>

        <p>На уровне сетевого взаимодействия было решено использовать модель префиксной сериализации. Каждый
            сериализованный объект предваряется двухбайтным заголовком, содержащим длину полезной нагрузки в байтах. Это
            позволяет принимать сообщения из асинхронного потока данных без необходимости сканирования или
            постобработки. Получатель сначала читает длину, затем указанное количество байт, после чего выполняет
            десериализацию. Такая модель позволяет полностью избежать проблем, связанных с неполными или
            фрагментированными сообщениями.</p>

        <p>Таким образом был выбран формат сериализации данных Postcard и префиксная передача сообщений для обмена
            информацией между компонентами подсистемы администрирования.</p>
    </hgroup>
    <hgroup>
        <h3 id="tools_db">Выбор базы данных</h3>

        <p>Обязательным элементом архитектуры подсистемы является хранение состояния. Такие компоненты подсистемы, как
            агент устройства и менеджер должны обладать возможностью сохранять и восстанавливать свое состояние, включая
            параметры конфигурации, историю операций, журнал событий и информацию о запущенных сервисах. Это необходимо
            как для обеспечения устойчивости к сбоям, так и для реализации идемпотентных операций и поддержания
            согласованного взаимодействия между распределенными участниками системы. Выбор подходящей системы хранения
            становится, таким образом, критически важным этапом проектирования.</p>

        <p>В качестве кандидатов рассматривались следующие подходы:</p>
        <ul class="dashenum">
            <li>Хранение в виде файлов формата JSON, YAML или TOML</li>
            <li>Использование хранилищ типа ключ-значение (например, RocksDB, sled)</li>
            <li>Использование встроенных реляционных баз данных (SQLite, DuckDB)</li>
            <li class="last">Использование полноценных СУБД с клиент-серверной архитектурой (PostgreSQL, MySQL)</li>
        </ul>

        <p>Первый вариант - файловое хранение в формате JSON или YAML обладает простотой реализации, лёгкой читаемостью
            и отсутствием внешних зависимостей. Однако он плохо масштабируется: при частых обновлениях возникают
            проблемы с конкуренцией на запись, отсутствует поддержка транзакций и индексов, сложно реализовать выборку
            по условиям. Кроме того, в случае сбоев или некорректного завершения процесса возникает риск частичной
            перезаписи и потери целостности данных. В условиях, когда компоненты системы могут перезапускаться, а
            состояние может обновляться асинхронно, такой способ является ненадежным.</p>

        <p>Хранилища типа ключ-значение, такие как RocksDB или sled, предлагают компактное бинарное хранение и высокую
            производительность, особенно при последовательном доступе. Однако их интерфейс недостаточно выразителен для
            хранения структурированных и взаимосвязанных данных. Например, чтобы сохранить зависимость между шагами
            сценария установки, необходимо вручную поддерживать сложную схему ключей и сериализовать каждую структуру.
            Кроме того, несмотря на встроенную поддержку транзакций, подобные решения не всегда обладают зрелыми
            механизмами восстановления после сбоев и часто требуют специфической настройки.</p>

        <p>Полноценные клиент-серверные СУБД, такие как PostgreSQL, обеспечивают богатую функциональность, поддержку
            индексов, транзакций, запросов, сложных схем. Однако они требуют развертывания отдельного сервера и наличия
            соединения с ним, что несовместимо с архитектурой подсистемы, предполагающей автономную работу на каждом
            устройстве. Запуск полноценного сервера БД на слабом оборудовании может быть избыточным.</p>

        <p>Наиболее подходящим решением представляется использование встроенной реляционной СУБД SQLite. Она не требует
            отдельного процесса, работает в рамках одного файла, обеспечивает транзакционность, поддержку индексов,
            запросов на выборку и обновление. Её производительность достаточна для задач хранения состояния сервисов,
            конфигурации и журналов событий, простота использования позволяет минимизировать накладные расходы на
            интеграцию. База данных является самодостаточной, её можно архивировать, переносить и восстанавливать без
            дополнительных зависимостей. [5, 6]</p>

        <p>На стороне агента база данных SQLite используется для хранения:</p>
        <ul class="dashenum">
            <li>текущего состояния каждого сервиса (установлен, сконфигурирован, запущен, в состоянии ошибке и т.д.)
            </li>
            <li>сохраненных аргументов конфигурации</li>
            <li>журнала событий от контроллеров</li>
            <li class="last">последней полученной статистики по использованию ресурсов</li>
        </ul>

        <p>На стороне менеджера в SQLite хранятся:</p>
        <ul class="dashenum">
            <li>список известных агентов и адреса их сокетов</li>
            <li>описание и последовательность шагов установки</li>
            <li>история выполнения сценариев</li>
            <li class="last">метаданные о состоянии каждого шага</li>
        </ul>

        <p>Таким образом, была выбрана база данных SQLite. Она позволяет гарантировать устойчивое и предсказуемое
            хранение состояния сервисов подсистемы администрирования.</p>
    </hgroup>
    <hgroup>
        <h3 id="tools_crypto">Выбор криптографических протоколов и модели аутентификации</h3>
        <p>Подсистема администрирования предполагает обмен управляющими командами и событиями между компонентами,
            находящимися на различных устройствах. Несмотря на то, что все устройства располагаются в закрытой сети,
            рассматриваются модели угроз, включающие возможный перехват сообщений, их модификацию, воспроизведение или
            подмену компонентов. В связи с этим требуется обеспечить конфиденциальность, целостность и подлинность всех
            передаваемых сообщений, что достигается путем установления защищённого канала связи и взаимной
            аутентификации сторон. Одновременно решение должно быть простым в эксплуатации и не зависеть от внешней
            инфраструктуры удостоверяющих центров.</p>

        <p>На этапе проектирования были рассмотрены следующие подходы:</p>
        <ul class="dashenum">
            <li>Использование протокола TLS с самоподписанными сертификатами</li>
            <li>Использование OpenSSH и его модели аутентификации</li>
            <li class="last">Протоколы на основе криптографических ключей и ручного обмена публичными ключами (например,
                Curve25519, Ed25519)</li>
        </ul>

        <p>Наиболее распространённым вариантом защищённого соединения является протокол TLS, который реализован во
            множестве библиотек, таких как OpenSSL или rustls. Однако его использование в закрытой сети сопряжено с
            рядом проблем. TLS требует наличия сертификатов, выданных доверенным удостоверяющим центром. Использование
            TLS с самоподписанными сертификатами теряет смысл в условиях, когда можно использовать генерируемые пары
            ключей. В целом, TLS — это достаточно тяжёлый и сложно настраиваемый протокол, избыточный для целевого
            применения (поддержка сессий, renegotiation, цепочки сертификатов и т.д.). [16]</p>

        <p>Модель OpenSSH предоставляет удобную инфраструктуру для подключения на основе публичных ключей. Однако она не
            предоставляет встроенного протокола обмена сообщениями в бинарной форме, требует поддержки оболочки и
            полноценной авторизации в системе, что делает её непригодной для узкоспециализированной коммуникации между
            сервисами. Кроме того, SSH предполагает ручное управление ключами и конфигурацией, что затрудняет
            автоматизацию.</p>

        <p>Наиболее подходящим в условиях закрытой среды является использование ключей X25519 или Ed25519, обладающих
            высокой криптостойкостью, малым размером, быстрым выполнением операций и стандартной поддержкой в
            большинстве криптографических библиотек. Передача публичных ключей между сторонами может осуществляться
            вручную на этапе установки, после чего используется механизм взаимного подтверждения владения
            соответствующим закрытым ключом.[8][9]</p>

        <p>В качестве протокола защищенного соединения был выбран Noise Protocol Framework, разработанный для построения
            криптографических рукопожатий с минимальным числом зависимостей и высокой степенью настраиваемости. Noise
            позволяет реализовать взаимную аутентификацию сторон, обмен эфемерными ключами, защиту от атак типа MITM и
            согласование общего симметричного ключа для последующего шифрования канала. Также Noise не требует наличия
            инфраструктуры сертификатов. [7]</p>

        <p>Библиотека Snow — реализация протокола Noise в языке Rust, используется для генерации, согласования и
            управления ключами, а также для шифрования и дешифрования сообщений. Она просто интегрируется с
            инструментами асинхронного программирования и совместима с используемым форматом сообщений. После завершения
            рукопожатия все данные, передаваемые между сторонами, шифруются с аутентификацией и защищены от подмены и
            повторов.</p>

        <p>Модель аутентификации базируется на предварительном знании публичных ключей. При установке агента его
            публичный ключ передаётся на менеджеру, где сохраняется в базе данных. Аналогично, ключ менеджера передается
            агенту. После этого любая попытка соединения с незарегистрированным ключом будет отвергнута. Такая модель
            обеспечивает проверяемое доверие без необходимости поддержки инфраструктуры доверия и минимизирует число
            действий администратора.</p>

        <p>Таким образом, был выбран протокол Noise для установления безопасного канала связи. Данный подход —
            оптимальный выбор для защищенной коммуникации в замкнутых и контролируемых сетях.</p>

    </hgroup>
    <hgroup>
        <h3 id="tools_ipc">Выбор модели межпроцессного взаимодействия</h3>
        <p>Компоненты подсистемы администрирования представляют собой иерархию процессов, выполняющихся на одном
            устройстве, например: агент, контроллер сервиса, консольный интерфейс. Для согласованного выполнения задач
            между этими процессами необходимо организовать надежный механизм межпроцессного взаимодействия (IPC),
            который бы обеспечивал:</p>
        <ul class="dashenum">
            <li class="dashenum">двустороннюю передачу сообщений (запросов и ответов)</li>
            <li>совместимость с асинхронной моделью исполнения</li>
            <li>передачу структурированных данных (в бинарной форме)</li>
            <li>устойчивость к прерыванию соединения и сбоям</li>
            <li class="last">простоту интеграции и поддержки</li>
        </ul>

        <p>При проектировании рассматривались различные подходы к IPC, доступные в среде Linux: каналы (pipe и FIFO),
            сигналы, разделяемая память, системные очереди сообщений, сетевые сокеты (в том числе Unix domain sockets).
        </p>

        <p>Наиболее простыми с точки зрения реализации являются именованные каналы и FIFO. Они позволяют передавать
            данные от одного процесса к другому, но они плохо масштабируются при необходимости одновременной работы с
            несколькими клиентами. Кроме того, работа с каналами затруднена в асинхронной среде.</p>

        <p>Разделяемая память обеспечивает высокую производительность и возможность передачи больших объемов данных
            между процессами. Однако, такая модель требует ручного управления синхронизацией доступа. Это приводит к
            увеличению сложности реализации, особенно при параллельной обработке и необходимости поддержания целостности
            данных.</p>

        <p>Сигналы и системные очереди сообщений позволяют реализовать простые нотификации, но не предназначены для
            передачи структурированных данных и асинхронной модели запросов с результатом. Они больше подходят для
            событийного управления, а не для полноценного обмена командами и результатами.</p>

        <p>Сетевые сокеты предоставляют универсальный интерфейс обмена сообщениями, совместимый с многозадачностью и
            асинхронной обработкой. Среди них особенно выделяются Unix domain сокеты, реализующие тот же API, что и
            TCP/IP-сокеты, но работающие внутри одного хоста, без необходимости сетевого стека. С их помощью, по
            аналогии с TCP и UDP, можно реализовать как потоковую передачу данных, так и передачу данных на основе
            дейтаграмм. Они совместимы со средствами асинхронной работы в Linux, например с epoll. В дополнение к этому,
            они естественным образом получают возможности управления правами доступа за счет использования файлов для
            адресации.[10]</p>

        <p>Таким образом, было решено использовать Unix Domain сокеты для взаимодействия процессов на одном устройстве
            между собой.</p>
    </hgroup>
</hgroup>